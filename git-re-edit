#!/usr/bin/perl
#
# Run the editor on all the files that have been modified from the
# current index.  Useful to resume work when you left the working tree
# dirty.  Useful following a "git reset HEAD^" to continue work on the
# stuff you were working on before.  Useful following a failed merge.

use strict;
use Getopt::Std;
my %opt = ( e => $ENV{VISUAL} || $ENV{EDITOR} || "emacs",
            c => 0,
            'q' => 0,
          );
getopts('e:cq', \%opt) or usage();
my $commit = shift;

my @command = (qw(git dirtyfiles),
               ($opt{q} ? ('-q') : ()),
               (defined($commit) ? ($commit) : ()),
    );

if ($opt{c}) {
    exec @command
        or die "Couldn't run @command: $!";
}

my @files;
{
    local $ENV{GIT_DIRTYFILES_NULSEP} = 1;
    open my ($f), "-|", @command
        or die "Couldn't run @command: $!";
    local $/ = "\0";
    chomp(@files = <$f>);
    close $f
        or die sprintf "git-dirtyfiles failed with exit status %d\n", $? >> 8;
}

unless (@files) {
    warn "No files to edit\n";
    exit;
}
    
# maybe should use output of "git var GIT_EDITOR" here?
# But then I have to involve the !@&*!@*(&!@ shell
my $ed = $opt{e};
exec $ed, @files;
die "exec $ed: $!\n";
