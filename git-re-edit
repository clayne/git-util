#!/usr/bin/perl
#
# Still fails when files may contain spaces
#
# Run the editor on all the files that have been modified from the
# current index.  Useful to resume work when you left the working tree
# dirty.  Useful following a "git reset HEAD^" to continue work on the
# stuff you were working on before.  Useful following a failed merge.
#
# I would like this to accept a command-line argument that names a
# commit; it should then edit all the files touched by the commit.
#
# There should also be an option to tell it not to suppress ?? files.

use Getopt::Std;
my %opt = ( e => $ENV{VISUAL} || $ENV{EDITOR} || "emacs",
            c => 0
          );
getopts('e:c', \%opt) or usage();

chomp(my @changed = grep !/^\?\? /, qx{git status --porcelain});
exit 1 unless $? == 0;
s/^.. // or die "<$_>???\n" for @changed;
die "Fucking shell, how does it work?\n"
    if grep / /, @changed;

@changed = qw(.) unless @changed;
chomp(my @lines = qx{find @changed -type f });
exit 1 unless $? == 0;
if ($opt{c}) {
    print join "\n", @lines, "";
    exit 0;
}

# maybe should use output of "git var GIT_EDITOR" here?
# But then I have to involve the !@&*!@*(&!@ shell
my $ed = $opt{e};
exec $ed, @lines;
die "exec $ed: $!\n";
