#!/usr/bin/perl
#
# Still fails when files may contain spaces
#
# Run the editor on all the files that have been modified from the
# current index.  Useful to resume work when you left the working tree
# dirty.  Useful following a "git reset HEAD^" to continue work on the
# stuff you were working on before.  Useful following a failed merge.
#
# There should also be an option to tell it not to suppress ?? files.

use strict;
use Getopt::Std;
my %opt = ( e => $ENV{VISUAL} || $ENV{EDITOR} || "emacs",
            c => 0
          );
getopts('e:c', \%opt) or usage();
my $commit = shift;
my @changed;

if ($commit) {
    chomp(@changed = grep /\S/, qx{git show --pretty="format:" --name-only $commit});
} else {
    chomp(@changed = grep !/^\?\? /, qx{git status --porcelain});
    exit 1 unless $? == 0;
    s/^.. // or die "<$_>???\n" for @changed;
    die "Fucking shell, how does it work?\n"
        if grep / /, @changed;

    unless (@changed) {
        warn "No files to edit\n";
        exit;
    }
    chomp(@changed = qx{find @changed -type f });
    exit 1 unless $? == 0;
}

if ($opt{c}) {
    print join "\n", @changed, "";
    exit 0;
}

# maybe should use output of "git var GIT_EDITOR" here?
# But then I have to involve the !@&*!@*(&!@ shell
my $ed = $opt{e};
exec $ed, @changed;
die "exec $ed: $!\n";
