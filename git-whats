#!/usr/bin/perl

$ENV{GIT_GET_NO_NEWLINE} = 1;

use Getopt::Long;
my $message;
my ($clear, $prune, $verbose, $noaction);
GetOptions ("set=s"     => \$message,
            "clear"     => \$clear,
            "prune"     => \$prune,
            "verbose|v" => \$verbose,
            "dry-run|n" => \$noaction,
           )
  or usage();

{
  if (!!$clear + !!$prune + !!defined($message) > 1) {
    warn "no more than one of --clear, --set, and --prune is allowed\n";
    usage();
  }
  if ($prune && @ARGV) {
    warn "--prune doesn't take any argument\n";
    usage();
  }
}

if ($clear) {
  $message = "";
}

prune_whats(), exit if $prune;

usage() if @ARGV && @ARGV != 1;
my $branch = shift;
$branch =  qx{git get current-branch-name}
  if ! defined($branch) || $branch eq "HEAD";

my $key = config_key($branch);

if (defined $message) {
  die "Detached HEAD\n" unless $branch =~ /\S/;
  if ($message eq "") {
    exit system(qw(git config --unset), $key);
  } else {
    exit system(qw(git config), $key, $message);
  }
} else {
  # Deal with arbitrary commit-ish some other time
  system(qw(git config), config_key($branch));
}

sub config_key {
  my ($ref) = @_;
  return "branch.$ref.what";
}

sub prune_whats {
  chomp(my @heads = qx{git get heads});
  my %head = map { $_ => 1 } @heads;
  for my $key (qx{git get config-keys}) {
    chomp $key;
    my ($branch) = $key =~ /^branch\.([^.]+)\.what$/ or next;
    if (! $head{$branch}) {
      warn "deleting $key\n";
      system("git config --unset-all $key") unless $noaction;
    }
  }
}

sub usage {
  die "Usage: git-whats [--set=...] [--clear] [branch]
       git-whats [-v] --prune\n";
}
